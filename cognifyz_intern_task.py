# -*- coding: utf-8 -*-
"""Cognifyz intern Task

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rZNYmp_8kyRPO76qoKcMZ9UtKBYV11Be

LEVEL-1   TASK-1->> Data Exploration and Preprocessing
"""

import pandas as pd

# Load the Dataset
df = pd.read_csv('/content/Dataset .csv')
df

"""DATA EXPLORATION STEPS"""

import numpy as np
# Get data dimensions (number of rows and columns)
print(df.shape)

# Check for missing values in each column
print(df.isnull().sum())

df.columns

df.dtypes

# Convert object columns to categorical data types
object_cols = ["Country Code", "City", "Address", "Locality", "Locality Verbose",
               "Cuisines", "Currency", "Switch to order menu", "Price range",
               "Rating color", "Rating text"]
df[object_cols] = df[object_cols].astype('category')
# Convert 'Yes' and 'No' to boolean values
df['Has Table booking'] = df['Has Table booking'].map({'Yes': True, 'No': False})
df['Has Online delivery'] = df['Has Online delivery'].map({'Yes': True, 'No': False})

# Check the data types after conversion
print("\nData types after conversion:")
print(df.dtypes)

"""RATING COUNTS TO EXAMINE CLASS IMBALANCES"""

import matplotlib.pyplot as plt

# Calculate the frequency of each rating
rating_counts = df['Aggregate rating'].value_counts().sort_index()

# Visualize the distribution of the target variable
plt.figure(figsize=(10, 6))
plt.bar(rating_counts.index, rating_counts.values, color='skyblue')
plt.title('Distribution of Aggregate Ratings')
plt.xlabel('Aggregate Rating')
plt.ylabel('Frequency')
plt.xticks(rotation=45)  # Rotate the x-axis labels by 45 degrees
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()  # Adjust layout to prevent overlapping
plt.show()

# Identify any class imbalances
# We can also print out the rating counts to examine class imbalances more closely
print("\nRating Counts:")
print(rating_counts)

"""LEVEL-1 TASK-2 ->> Descriptive Analysis"""

# Calculate basic statistical measures for numerical columns
numerical_stats = df.describe()

# Display the calculated statistics
print("Basic Statistical Measures for Numerical Columns:")
print(numerical_stats)

"""LEVEL-1 TASK-3 ->> Geospatial Analysis"""

import matplotlib.pyplot as plt

# Explore the distribution of "Country Code"
country_counts = df['Country Code'].value_counts()
print("\nDistribution of Country Code:")
print(country_counts)

# Explore the distribution of "City"
city_counts = df['City'].value_counts()
print("\nDistribution of City:")
print(city_counts)

# Explore the distribution of "Cuisines"
cuisine_counts = df['Cuisines'].value_counts()
print("\nDistribution of Cuisines:")
print(cuisine_counts)

# Identify the top cuisines
top_cuisines = cuisine_counts.head(10)
print("\nTop 10 Cuisines:")
print(top_cuisines)

# Identify the top cities with the highest number of restaurants
top_cities = city_counts.head(10)
print("\nTop 10 Cities with the Highest Number of Restaurants:")
print(top_cities)


# Visualize the distribution of "Country Code"
plt.figure(figsize=(10, 6))
country_counts.plot(kind='bar', color='skyblue')
plt.title('Distribution of Country Code')
plt.xlabel('Country Code')
plt.ylabel('Number of Restaurants')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

print("\t")  # Add a tab space


# Visualize the distribution of "City"
plt.figure(figsize=(12, 6))
city_counts.head(20).plot(kind='bar', color='salmon')
plt.title('Distribution of City (Top 20)')
plt.xlabel('City')
plt.ylabel('Number of Restaurants')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

print("\t")  # Add a tab space


# Visualize the distribution of "Cuisines" (Top 10)
plt.figure(figsize=(12, 6))
top_cuisines.plot(kind='bar', color='lightgreen')
plt.title('Top 10 Cuisines')
plt.xlabel('Cuisine')
plt.ylabel('Number of Restaurants')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

print("\t")  # Add a tab space

pip install folium

import folium

# Create a map centered at the mean latitude and longitude
map_center = [df['Latitude'].mean(), df['Longitude'].mean()]
mymap = folium.Map(location=map_center, zoom_start=10)

# Add markers for each restaurant location
for index, row in df.iterrows():
    folium.Marker(location=[row['Latitude'], row['Longitude']],
                  popup=row['Restaurant Name'],
                  tooltip=row['Restaurant Name']).add_to(mymap)

# Display the map
mymap

"""LEVEL-2 TASK-1 -->> Table Booking and Online Delivery"""

# Calculate the percentage of restaurants that offer table booking
table_booking_percentage = (df['Has Table booking'].sum() / len(df)) * 100

# Calculate the percentage of restaurants that offer online delivery
online_delivery_percentage = (df['Has Online delivery'].sum() / len(df)) * 100

# Print the results
print("Percentage of restaurants that offer table booking: {:.2f}%".format(table_booking_percentage))
print("Percentage of restaurants that offer online delivery: {:.2f}%".format(online_delivery_percentage))

# Check for missing values in the "Has Table booking" column
print("Number of missing values in 'Has Table booking':", df['Has Table booking'].isnull().sum())

# Calculate the average ratings for restaurants with table booking and without
avg_rating_with_table_booking = df[df['Has Table booking'].notnull()]['Aggregate rating'].mean()
avg_rating_without_table_booking = df[df['Has Table booking'].isnull()]['Aggregate rating'].mean()

# Print the results
print("Average rating for restaurants with table booking:", avg_rating_with_table_booking)
print("Average rating for restaurants without table booking:", avg_rating_without_table_booking)

# Group the data by price range and calculate the percentage of restaurants offering online delivery in each group
online_delivery_percentage_by_price_range = df.groupby('Price range')['Has Online delivery'].mean() * 100

# Print the results
print("Online Delivery Percentage by Price Range:")
print(online_delivery_percentage_by_price_range)

"""LEVEL-2 TASK-2 -->> Price Range Analysis"""

# Determine the most common price range among all the restaurants
most_common_price_range = df['Price range'].mode()[0]

# Print the result
print("The most common price range among all the restaurants:", most_common_price_range)

# Calculate the average rating for each price range
avg_rating_by_price_range = df.groupby('Price range')['Aggregate rating'].mean()

# Print the results
print("Average rating for each price range:")
print(avg_rating_by_price_range)

# Calculate the average rating for each price range
avg_rating_by_price_range = df.groupby('Price range')['Aggregate rating'].mean()

# Find the price range with the highest average rating
highest_avg_rating_price_range = avg_rating_by_price_range.idxmax()

# Determine the corresponding color for the highest average rating price range
highest_avg_rating_color = df[df['Price range'] == highest_avg_rating_price_range]['Rating color'].iloc[0]

# Print the result
print("The color that represents the highest average rating among different price ranges:", highest_avg_rating_color)

"""LEVEL-2 TASK-3 -->> Feature Engineering"""

# Extract additional features: length of restaurant name and address
df['Restaurant Name Length'] = df['Restaurant Name'].apply(lambda x: len(str(x)))
df['Address Length'] = df['Address'].apply(lambda x: len(str(x)))

# Print the first few rows to verify the new features
print(df[['Restaurant Name', 'Restaurant Name Length', 'Address', 'Address Length']].head())

# Assuming you have already loaded the DataFrame df

# Perform one-hot encoding for 'Has Table booking' and 'Has Online delivery' separately
table_booking_encoded = pd.get_dummies(df['Has Table booking'], prefix='Has_Table_Booking')
online_delivery_encoded = pd.get_dummies(df['Has Online delivery'], prefix='Has_Online_Delivery')

# Concatenate the encoded columns with the original DataFrame
df_encoded = pd.concat([df, table_booking_encoded, online_delivery_encoded], axis=1)

# Print the first few rows including the encoded columns
print(df_encoded)